function suit_normalize_dartel(job,varargin);
% function suit_normalize_dartel(job,varargin);
% Normalizes the gray/white matter segmentation maps to the SUIT template, 
% using Dartel. Notice that as opposed to other Dartel applications, here 
% no new template is generated, rather, a the predefined White-matter / 
% Gray matter template from SUIT is used. 
% Dartel is written by John Ashburner and part of the SPM8 / SPM12 package. 
% _________________________________________________________________________
% INPUT: 
%   job:            job structure from the Batch system (can also be generated by code)
%       job.subjND: Nx1 Structure with individual subjects using fields
%           .gray:  Cell array with file name of gray-matter segmentation image e.g., {'c1T1.nii'}
%           .white:  Cell array with file name of gray-matter segmentation image e.g., {'c2T1.nii'}
%           .isolation:  Cell array with file name of isolation map e.g., {'T1_pcereb_corr.nii'}
%__________________________________________________________________________
% OPTIONS:
%   'template',filename: Specify a template other than SUIT
%__________________________________________________________________________
% OUTPUT:
%    Writes two files in the directory of the gray-matter image: 
%       Affine_<name>.mat: Matrix that contains linear part of the mapping 
%       u_a_<name>.nii   : Flow field that contains the nonlinear part of the mapping
%__________________________________________________________________________
% EXAMPLE:
%   for s = 1:N % for each subject
%       job.subjND(s).gray = {['<name>_' subjName{s} '_seg1.nii']}; % where subjName is a cell array of subject names
%       job.subjND(s).white = {['<name>_' subjName{s} '_seg2.nii']};
%       job.subjND(s).isolation = {['<name>_' subjName{s} '_pcereb.nii']};
%   end
%   suit_normalise_dartel(job);
% ----------------------------------------------------------------------
% Joern Diedrichsen 07/04/2013 j.diedrichsen@ucl.ac.uk
% Diedrichsen, J. (2006). A spatially unbiased atlas template of the human
% cerebellum. Neuroimage.
% Thanks to John Ashburner for help and 
% Dagmar Timmann for data and motivation 

% v.2.6: First version: SPM12 compatible 
% v.2.7: renaming of the template to SUIT_dartel1_x.nii
%        masking before affine alignment 
% v.3.0: SPM 12 compatibility 

% Check input 
global defaults;
spmVer=spm('Ver');
switch(spmVer)
    case {'SPM5','SPM8'}
        suit_dir=fileparts(which('suit_normalize_dartel.m')); 
        template_dir=fullfile(suit_dir,'templates');
    case {'SPM12b','SPM12'}
        template_dir=fullfile(defaults.tbx.dir{1},'suit','templates');
    otherwise
        warning(sprintf('Unknown SPM-version: %s',spmVer)); 
end;
for i=1:6
    template{i}=sprintf('%s/SUIT_dartel1_%d.nii',template_dir,i);
end;
affine_prefix='a';


% Deal with variable arguments:
vararginoptions(varargin,{'template'});

SCCSid   = '3.0';
SPMid    = spm('FnBanner',mfilename,SCCSid);

% Now loop over Subjects 
numsubj=length(job.subjND);
for s=1:numsubj
    S=job.subjND(s);
    
    % Read each Subjects images
    V(1)=spm_vol(S.gray{1});
    V(2)=spm_vol(S.white{1});
    V(3)=spm_vol(S.isolation{1});
    [subj_dir,filename{1},ext{1}]=spm_fileparts(S.gray{1});
    [~,filename{2},ext{2}]=spm_fileparts(S.white{1});
    VA=spm_vol([template{1} ',1']);

    % Make sure that mask volume is maximally 1 
    X=spm_read_vols(V(3)); 
    X=X./max(X(:)); 
    spm_write_vol(V(3),X); 

    % mask the images with the isolation map 
    for i=1:2 
        Vm(i)=V(i); 
        Vm(i).fname=fullfile(subj_dir,['m' filename{i} ext{i}]);
        Vm(i)=spm_imcalc(V([i 3]),Vm(i),'i1.*i2'); 
    end; 

    % get Affine Alignment to SUIT
    aflags.smosrc=5;
    aflags.regtype='subj';
    aflags.WF=[]; 
    aflags.weight=[];
    Affine=spmj_get_affine_mapping(Vm(1),VA,aflags);
    
    % Sample and multiply with masking volumne
    [X,Y,Z]=ndgrid(1:VA.dim(1),1:VA.dim(2),1:VA.dim(3));
    num_slice=VA.dim(3);
    for i=1:2
        [Xm,Ym,Zm]=spmj_affine_transform(X,Y,Z,inv(Affine*Vm(i).mat)*VA.mat);
        for z=1:num_slice
            Data(:,:,z,i)=spm_sample_vol(Vm(i),Xm(:,:,z),Ym(:,:,z),Zm(:,:,z),1);
        end;
    end;
    
    % Write out the affine-aligned images as precursor to Dartel
    % deformation 
    for i=1:2
        Out(i)=Vm(i);
        Out(i).dim=VA.dim;
        Out(i).mat=VA.mat;
        Out(i).fname=fullfile(subj_dir,['a_' filename{i},ext{i}]);
        spm_write_vol(Out(i),Data(:,:,:,i));
    end;

    % Now morph the two using dartel 
    rparam={[4 2 1e-06],[2 1 1e-06],[1 0.5 1e-06],[0.5 0.25 1e-06],[0.25 0.125 1e-06],[0.25 0.125 1e-06]};
    K=[0 0 1 2 4 6];
    w.images = {
        {Out(1).fname}
        {Out(2).fname}
        }';
    w.settings.rform = 0;
    for i=1:6
        w.settings.param(i).its = 3;
        w.settings.param(i).rparam = rparam{i};
        w.settings.param(i).K = K(i);
        w.settings.param(i).template = {template{i}}; 
    end;
    w.settings.optim.lmreg = 0.01;
    w.settings.optim.cyc = 3;
    w.settings.optim.its = 3;
    spm_dartel_warp(w);
    save(fullfile(subj_dir,['Affine_' filename{1} '.mat']),'Affine'); 
    
    % Delete temporary files 
    for i=1:2 
        delete(Vm(i).fname);
        delete(Out(i).fname); 
    end; 
end;

function [y1,y2,y3] = spmj_affine_transform(x1,x2,x3,M)
% function [y1,y2,y3] = affine_transform(x1,x2,x3,M)
% -----------------------------------------------------------------
% Affine Transform for input stuff in any format (N-dim strcutures)
% -----------------------------------------------------------------
y1 = M(1,1)*x1 + M(1,2)*x2 + M(1,3)*x3 + M(1,4);
y2 = M(2,1)*x1 + M(2,2)*x2 + M(2,3)*x3 + M(2,4);
y3 = M(3,1)*x1 + M(3,2)*x2 + M(3,3)*x3 + M(3,4);

